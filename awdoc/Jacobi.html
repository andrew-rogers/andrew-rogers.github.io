<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0" charset="UTF-8">
    <script src="AndrewWIDE.js"></script>
	</head>
	<body>
		<textarea id="aw_json" class="awjson" hidden>

AW{"type":"javascript", "hidden":"true"}
let id = AndrewWIDE.suspend("Loading ellip.js");
require(['ellip'], function (e) {
  window.EL = e;
  AndrewWIDE.resume(id);
});

AW{"type":"mjmd"}

Jacobi Elliptic Functions
=========================

[Jacobian Elliptic Function Tables](https://www.dbraulibrary.org.in/RareBooks/Jacobian%20elliptic%20function%20tables.pdf)

The Legendre form incomplete elliptic integral of the frist kind is defined as 

$$ F(\varphi,m) = \int_0^\varphi \frac{1}{\sqrt{1-m\sin^2\theta}}\mathrm{d}\theta $$

Complete Elliptic Integral
--------------------------

$$ K(m) = F\left(\frac{\pi}{2},m\right) $$

From tables pg 42 $ K(0.4) = 1.77752 $

The Complete Elliptic Integral can be computed using numerical integration as below:

AW{"type":"javascript"}
function integrate(func, ll, ul, N) {
  let ss = (ul-ll)/N;
  let f0 = func(ll);
  let area = 0;
  for (let n=1; n<=N; n++) {
    let f1 = func(n*ss);
    area += (f0+f1)*ss;
    f0 = f1;
  }
  return area/2;
}

function F(phi,m) {
  function r(theta,m){
    const s = Math.sin(theta);
    return 1/Math.sqrt(1-m*s*s);
  }

  return integrate((theta)=>r(theta,m),0,phi,100);
}

function K(m) {
  const phi = Math.PI / 2;
  return F(phi,m);
}

window.JEF = {F, K}; // Exported functions

console.log("K(0.4) = ", JEF.K(0.4));

AW{"type":"mjmd"}

Jacobi Amplitude
----------------

$$ \mathrm{am}(u ,m) = \varphi $$

As the Jacobi Amplutide function is the inverse of $u = F(\varphi,m)$, a binary search is performed to evaluate $\mathrm{am}(u,m)$. 

AW{"type":"javascript"}

function find(func, ll, ul, y) {
  let x = ll;
  for (let n=0; n<100; n++) {
    x = (ll + ul) / 2;
    let val = func(x);
    if (val>y) ul = x;
    else ll = x;
  }
  return x;
}

JEF.am = function(u, m) {
  return find((phi) => JEF.F(phi,m), 0, Math.PI/2, u);
}

AW{"type":"mjmd"}
The AGM is a more efficient means of evaluating $\mathrm{am}(u,m)$ and will be presented later.

Jacobi sn(u,m)
--------------

From tables pg 42 $\mathrm{sn}(0.15, 0.4) = 0.14922 $.

AW{"type":"javascript"}
JEF.sn = function(u, m) {
  return Math.sin(JEF.am(u,m));
}

JEF.arcsn = function(x, m) {
  return JEF.F(Math.asin(x), m);
}

console.log("sn(0.15, 0.4) =", JEF.sn(0.15, 0.4));
console.log("arcsn(0.14922, 0.4) =", JEF.arcsn(0.14922, 0.4));

AW{"type":"javascript"}
const m=0.4;
const K = JEF.K(m);

let sn_lut=[];
for (let n=0; n<200; n++) {
  let u = n*K/200;
  sn_lut.push(JEF.sn(u,m));
}
sn_lut.push(1);

let x = [];
let y = [];
for (let n=0; n<1000; n++) {
  let index = n % 400;
  if (index>200) index = 400 - index;
  x.push(n*K/200);

  if (Math.floor(n/400)%2) {
    y.push(-sn_lut[index]);
  } else {
    y.push(sn_lut[index]);
  }
}

plot(x,y);
xlabel("u");
ylabel(`sn(u,${m})`);

AW{"type":"mjmd"}
Arithmetic-Geometric Mean (AGM)
-------------------------------

The definition of the AGM algorithm can be found in [DLMF](https://dlmf.nist.gov/22.20).

$$ \begin{align}
      a_n &= \frac{a_{n-1}+b_{n-1}}{2} \\
      b_n &= \sqrt{a_{n-1}b_{n-1}} \\
      c_n &= \frac{a_{n-1}-b_{n-1}}{2}
\end{align} $$

Iterations are performed until $c_N$ is zero to the desired accuracy. For $c_N < \epsilon$, $N$ is typically five or six.
$\epsilon$ is the [Machine epsilon](https://en.wikipedia.org/wiki/Machine_epsilon).

AW{"type":"javascript"}
JEF.agm = function(a,b,c) {
  let arr_a = [];
  let arr_b = [];
  let arr_c = [];
  for (let n = 0; n < 20; n++) {
    arr_a.push(a);
    arr_b.push(b);
    arr_c.push(c);
    if (Math.abs(c/a) < Number.EPSILON) break;

    let ta = a;
    let tb = b;
    a = (ta + tb) / 2.0;
    b = Math.sqrt(ta * tb);
    c = (ta - tb) /2.0;
  }
  return [arr_a, arr_b, arr_c];
}

AW{"type":"mjmd"}
The graph plot below shows a and b converging very rapidly.
      
AW{"type":"javascript"}
[a, b, c] = JEF.agm(1, 0.3, 0.5);

plot(a).name('a');
plot(b).name('b');
plot(c).name('c');
xlabel('iteration (n)');

AW{"type":"mjmd"}
To use the AGM to evaluate the Jacobi Amplitude function, $\mathrm{am}(u,m)$, a reverse iteration using the AGM iteration values is performed

$$ \varphi_N = 2^N a_N u $$
$$ x_n = \frac{c_n}{a_n} \sin(\varphi_n) $$
$$ \varphi_{n-1} = \frac{\mathrm{arcsin}(x_n)+\varphi_n}{2} $$

The AGM iteration values are evaluated by initialising the AGM with $a_0 = 1.0$, $b_0 = k^\prime$ and $c_0 = k$.

DLMF uses $k$ whereas the tables use $m$, they are related by $k = \sqrt{m}$ and $k^\prime = \sqrt{1-m}$.

AW{"type":"javascript"}
JEF.agm_am = function(u,m) {
  let a = 1.0;
  let b = Math.sqrt(1.0 - m); // DLMF uses k, k' whereas the tables use m and 1-m. m=k^2
  let c = Math.sqrt(m);
  [a, b, c] = JEF.agm(a, b, c);

  let N = a.length - 1;
  let phi = (2.0 ** N) * a[N] * u;
  for (let n = N; n > 0; n--) {
    let x = c[n] * Math.sin(phi) / a[n];
    phi = (Math.asin(x) + phi) / 2.0;
  }

  return phi;
}

AW{"type":"mjmd"}
Carlson Symmetric Form
----------------------

The incomplete elliptical integrals can also the evaluated by the [numeric evaluation of the Carlson symmetric form](https://en.wikipedia.org/wiki/Carlson_symmetric_form#Numerical_evaluation)

$$ \lambda_n = \sqrt{x_n y_n} + \sqrt{y_n z_n} + \sqrt{z_n x_n} $$

$$ x_{n+1} = \frac{x_n + \lambda_n}{4}, y_{n+1} = \frac{y_n + \lambda_n}{4}, z_{n+1} = \frac{z_n + \lambda_n}{4} $$

AW{"type":"javascript"}
JEF.Rf = function(x,y,z) {
  let arr_x = [];
  let arr_y = [];
  let arr_z = [];

  for (let n = 0; n < 100; n++) {
    arr_x.push(x);
    arr_y.push(y);
    arr_z.push(z);
    let error = Math.abs((x-y)/z) + Math.abs((y-z)/x) + Math.abs((z-x)/y);
    if (error < Number.EPSILON) break;

    let lambda = Math.sqrt(x * y) + Math.sqrt(y * z) + Math.sqrt(z * x);
    x = (x + lambda) / 4;
    y = (y + lambda) / 4;
    z = (z + lambda) / 4;
  }

  return [arr_x, arr_y, arr_z];
}

AW{"type":"javascript"}
[x,y,z] = JEF.Rf(0.7,0.1,0.4);
plot(x).name('x');
plot(y).name('y');
plot(z).name('z');
xlabel('Iteration (n)');

AW{"type":"javascript"}
let m = 0.4;
let rf = JEF.Rf(0, 1-m, 1);
let rf_arr_x = rf[0];
let mu = rf_arr_x[rf_arr_x.length-1];
let K = 1/Math.sqrt(mu);
console.log(`K(${m}) = ${K}`);
      
		</textarea>
		<script>
      new AwDocViewer( "serverless" );
		</script>
	</body>
</html>
