<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0" charset="UTF-8">
    <script src="AndrewWIDE.js"></script>
	</head>
	<body>
		<textarea id="aw_json" class="awjson" hidden>

AW{"type":"javascript", "hidden":"true"}
AndrewWIDE.loadWasmDSPModules(['signal']);

AW{"type":"mjmd"}

Design Notes for the WasmDSP Filter Functions
=============================================

Frequency Scaling
-----------------

The single pole analogue prototype Butterworth filter has the transfer function

$$ H_p(s) = \frac{1}{s+1} $$

Its single pole is located at -1. The DC gain is found by letting $s=0$

$$ H_p(0) = \frac{1}{1} = 1 $$

Frequency scaling by $\omega_0$ gives the transfer function

$$ H(s) = \frac{1}{s+\omega_c} $$

and its DC gain is

$$ H(0) = \frac{1}{\omega_c} $$

The gain compensation factor for the scaled first order Butterworth filter is therefore $k = \omega_c $. For a second order filter the gain compesation factor would be $k = \omega_c^2$. In general the scaled lowpass filter with $N$ fewer zeros than poles has a gain compensation factor of

$$ k = \omega_c^N $$

### Highpass Filter

The lowpass prototype has the transfer function

$$\begin{align}
      H_p(s) &= \frac{(s-s_{z,1})(s-s_{z,2})\dots(s-s_{z,N})}{(s-s_{p,1})(s-s_{p,2})\dots(s-s_{p,N})} \\
             &= \frac{\prod(s-s_{z,n})}{\prod(s-s_{p,n})}
\end{align} $$

and passband gain at $s=0$

$$ H_p(0) = \frac{\prod(-s_{z,n})}{\prod(-s_{p,n})} $$

For the highpass filter the roots are inverted and scaled by $\omega_0$ to give

$$ H(s) = \frac{\prod\left(s-\frac{\omega_0}{s_{z,n}}\right)}{\prod\left(s-\frac{\omega_0}{s_{p,n}}\right)} $$

The gain in the passband is consider at the limit $s \to \infty$

$$ \lim_{s \to \infty} H(s) = 1 $$

The gain compensation factor is

$$ k = \frac{\prod(-s_{z,n})}{\prod(-s_{p,n})} $$

### Bandpass Filter

$$ s \longmapsto \frac{\omega_0}{b}\left(\frac{s}{\omega_0}+\frac{\omega_0}{s}\right) $$

$$ s \longmapsto \frac{s^2 + \omega_0^2}{sb} $$

$$ \frac{1}{s-s_p} \longmapsto \frac{1}{\frac{s^2 + \omega_0^2}{sb} - s_p} $$

$$ \begin{align}
      \frac{1}{\frac{s^2 + \omega_0^2}{sb} - s_p} &= \frac{s}{\frac{1}{b}s^2 - ss_p + \frac{\omega_0^2}{b}}
\end{align} $$

To find the two poles, find the roots of the denominator

$$ \begin{align}
      s_{p01} &= \frac{s_p\pm\sqrt{s_p^2-\frac{4}{b}\frac{\omega_0^2}{b}}}{\frac{2}{b}} \\
              &= \frac{bs_p}{2} \pm \sqrt{\left(\frac{bs_p}{2}\right)^2 - \omega_0^2}
\end{align} $$

Applying the lowpas scaling factor $b/2$ to give $s_{pb} = bs_p/2$ simplifies the band transformation to

$$ s_{p01} = s_{pb} \pm \sqrt{s_{pb}^2 - \omega_0^2}$$

Bilinear Z-transform
--------------------

Consider an analogue filter with one zero and one pole

$$ H_a(s) = \frac{s-s_z}{s-s_p} $$

The DC gain is

$$ H_a(0) = \frac{-s_z}{-s_p} $$

Obtain the digital filter by applying the BZT to the roots

$$ H_d(z) = \frac{z-\frac{2+s_z}{2-s_z}}{z-\frac{2+s_p}{2-s_p}} $$

Let $z=1$ to obtain DC gain

$$\begin{align}
      H_d(1) &= \frac{1-\frac{2+s_z}{2-s_z}}{1-\frac{2+s_p}{2-s_p}} \\
           &= \frac{(2-s_z)(2-s_p)-(2-s_p)(2+s_z)}{(2-s_z)(2-s_p)-(2-s_z)(2+s_p)} \\
           &= \frac{2-s_p}{2-s_z}\times\frac{(2-s_z)-(2+s_z)}{(2-s_p)-(2+s_p)} \\
           &= \frac{2-s_p}{2-s_z}\times\frac{-2s_z}{-2s_p} \\
           &= \frac{2-s_p}{2-s_z}\times H_a(0)
\end{align}$$

The gain compensation factor for the first order filter is therefore

$$ k = \frac{2-s_z}{2-s_p} $$

This can be generalised for higher degree filters

$$ k = \frac{\prod(2-s_{z,n})}{\prod(2-s_{p,n})} $$

Examples from the WasmDSP Signal Processing Module
==================================================

A function to plot the frequency response is defined

AW{"type":"javascript"}
window.signal = AndrewWIDE.WasmDSP.modules.signal;

window.sosfreqz = function(sos) {
  let [h,w] = signal.sosfreqz(sos);
  hmag = h.map((v) => 20 * Math.log10(Math.sqrt(v[0] * v[0] + v[1] * v[1])));
  plot(w, hmag);
  xlabel("&omega;");
  ylabel("|H(z)| (dB)");
}

AW{"type":"javascript"}
let sos = signal.butter(4,0.1);
sosfreqz(sos);

AW{"type":"javascript"}
let sos = signal.ellip(5,1,40,0.1);
sosfreqz(sos);

AW{"type":"javascript"}
let sos = signal.ellip(5,1,40,0.1,'hp');
sosfreqz(sos);

AW{"type":"javascript"}
let sos = signal.ellip(4,1,40,[0.1, 0.15],'bp');
sosfreqz(sos);

AW{"type":"javascript"}
let sos = signal.ellip(4,1,40,[0.1, 0.15],'bs');
sosfreqz(sos);

		</textarea>
		<script>
      new AwDocViewer( "serverless" );
		</script>
	</body>
</html>
