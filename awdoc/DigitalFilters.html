<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0" charset="UTF-8">
    <script src="AndrewWIDE.js"></script>
	</head>
	<body>
		<textarea id="aw_json" class="awjson" hidden>

AW{"type":"javascript", "hidden":"true"}
AndrewWIDE.loadWasmDSPModules(['signal']);

AW{"type":"mjmd"}

Design Notes for the WasmDSP Filter Functions
=============================================

Frequency Scaling
-----------------

The single pole analogue prototype filter has the transfer function

$$ H(s) = \frac{1}{s+1} $$

The DC gain is found by letting $s=0$

$$ H(0) = \frac{1}{1} = 1 $$

Frequency scaling by $\omega_0$ gives the transfer function

$$ H(s) = \frac{1}{s+\omega_c} $$

and its DC gain is

$$ H(0) = \frac{1}{\omega_c} $$

The gain compensation factor for the scaled first order Butterworth filter is therefore $k = \omega_c $. For a second order filter the gain compesation factor would be $k = \omega_c^2$. Genrally speaking the scaled lowpass filter with $N$ fewer zeros than poles has a gain compensation factor of

$$ k = \omega_c^N $$

Bilinear Z-transform
--------------------

Consider an analogue filter with one zero and one pole

$$ H_a(s) = \frac{s-s_z}{s-s_p} $$

The DC gain is

$$ H_a(0) = \frac{-s_z}{-s_p} $$

Obtain the digital filter by applying the BZT to the roots

$$ H_d(z) = \frac{z-\frac{2+s_z}{2-s_z}}{z-\frac{2+s_p}{2-s_p}} $$

Let $z=1$ to obtain DC gain

$$\begin{align}
      H_d(1) &= \frac{1-\frac{2+s_z}{2-s_z}}{1-\frac{2+s_p}{2-s_p}} \\
           &= \frac{(2-s_z)(2-s_p)-(2-s_p)(2+s_z)}{(2-s_z)(2-s_p)-(2-s_z)(2+s_p)} \\
           &= \frac{2-s_p}{2-s_z}\times\frac{(2-s_z)-(2+s_z)}{(2-s_p)-(2+s_p)} \\
           &= \frac{2-s_p}{2-s_z}\times\frac{-2s_z}{-2s_p} \\
           &= \frac{2-s_p}{2-s_z}\times H_a(0)
\end{align}$$

The gain compensation factor for the first order filter is therefore

$$ k = \frac{2-s_z}{2-s_p} $$

This can be generalised for higher degree filters

$$ k = \frac{\prod(2-s_{z,n})}{\prod(2-s_{p,n})} $$

Examples from the WasmDSP Signal Processing Module
==================================================

A function to plot the frequency response is defined

AW{"type":"javascript"}
window.signal = AndrewWIDE.WasmDSP.modules.signal;

window.sosfreqz = function(sos) {
  let [h,w] = signal.sosfreqz(sos);
  hmag = h.map((v) => 20 * Math.log10(Math.sqrt(v[0] * v[0] + v[1] * v[1])));
  plot(w, hmag);
  xlabel("&omega;");
  ylabel("|H(z)| (dB)");
}

AW{"type":"javascript"}
let sos = signal.butter(4,0.1);
sosfreqz(sos);

AW{"type":"javascript"}
let sos = signal.ellip(5,1,40,0.1);
sosfreqz(sos);

AW{"type":"javascript"}
let sos = signal.ellip(5,1,40,0.1,'hp');
sosfreqz(sos);

		</textarea>
		<script>
      new AwDocViewer( "serverless" );
		</script>
	</body>
</html>
